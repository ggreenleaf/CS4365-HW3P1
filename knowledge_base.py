class KnowledgeBase:
	def __init__(self,filename):
		with open(filename) as f:
			data = f.read()
		
		self.kb = []
		i = 1
		for line in data.split("\n"):
			line_list = line.split(" ")
			line_list.sort() #sort to avoid created multiple clauses with different order literal
			line = " ".join(line_list)
			self.kb.append((i,line,"{}"))
			i += 1

	def display(self):
		for num,clause,parents in self.kb:
			print "%i."%num,clause,parents
		
		print "Size of final clause set: %i"%len(self.kb)
	
	def negate_literal(self,lit):
		'''negates a single literal ~p ==> p or p ==> ~p''' 
		return lit[1:] if lit[0] == "~" else "~%s"%lit
			  
	def resolve(self,c1,c2):
		'''removes contradictions in two clauses and returns list of clauses created'''
		clauses = []
		for a1 in c1[1].split(" "):
			for a2 in c2[1].split(" "):
				if a1 == self.negate_literal(a2) or a2 == self.negate_literal(a1):
					# new_clause = " ".join(set(self.remove(a1,c1) + self.remove(a2,c2) + self.remove(a2,c1)+ self.remove(a1,c2))) #remove repated literals 
					new_clause = " ".join(self.remove(c1,c2,a1,a2)) #create new clause removing instances of a1 and a2
					if not new_clause: #empty clause after remove means contradiction found
						new_clause = "False"
						
					clauses.append(new_clause)

		return clauses

		# return list of literals for new_clause 
	def remove(self,c1,c2,a1,a2):
		'''remove all instances of a1 and a2 from merged c1 and c2'''
		merged = c1[1].split(" ") + c2[1].split(" ")
		merged = filter(lambda x: x != a1 and x != a2, merged)

		merged = self.resolve_contradictions(merged) #need to remove contradictions in merged clause
		return sorted(list(set(merged)))
	
	def resolve_contradictions(self,clause_list):
		'''removes contradicting literals from clause_list'''
		new = clause_list[:]
		for i in clause_list:
			negated = self.negate_literal(i)
			if negated in clause_list: #if negated in list remove both negated and literal
				while i in new or negated in new:
						new.remove(i); new.remove(negated)
		return new
				

	def get_kb_set(self):
		'''returns the set of the knowledge base where each element is a clause)'''
		return set([x[1] for x in self.kb]) 
	
	def resolution(self):
		'''use resolution principle to test validity of clause a'''
		new_clauses = set() #set of tuples generated by resolve each element is clause,{parents_num}
		breakFlag = False 

		while True:
				n = len(self.kb)
				pairs = [(self.kb[i],self.kb[j]) for i in xrange(n) for j in xrange(i+1,n)]
				for (c1,c2) in pairs: 
					resolvents = self.resolve(c1,c2)


					if "False" in resolvents:
						self.kb.append((len(self.kb) +  1, "False","{%i %i}"%(c1[0],c2[0])))
						return True
					resolve_parents = [(clause, "{%i %i}"%(c1[0],c2[0]))  for clause in resolvents] #add parents to resolvents
				
					new_clauses.update(set(resolve_parents))

				if set([x[0] for x in new_clauses]).issubset(self.get_kb_set()): 
					return False

				for c in new_clauses:
					if c[0] not in self.get_kb_set():
						 self.kb.append((len(self.kb)+1,c[0],c[1]))