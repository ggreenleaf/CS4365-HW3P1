class KnowledgeBase:
	def __init__(self,filename):
		with open(filename) as f:
			data = f.read()
		
		self.kb = []
		i = 1
		for line in data.split("\n"):
			# line_list = line.split(" ")
			# line_list.sort()
			# line = " ".join(line_list)
			self.kb.append((i,line,"{}"))
			i += 1

	def display(self):
		for num,clause,parents in self.kb:
			print "%i."%num,clause,parents
		
		print "Size of final clause set: %i"%len(self.kb)
	
	def negate_literal(self,lit):
		'''negates a single literal ~p ==> p or p ==> ~p''' 
		return lit[1:] if lit[0] == "~" else "~%s"%lit
			  
	# def negate_clause(self, clause):
	# 	'''negates a clause and inserts into kb'''
	# 	clause_num = len(self.kb) + 1
	# 	for literal in sorted(clause.split(" ")):
	# 		negated = self.negate_literal(literal)
	# 		if negated not in [i[1] for i in self.kb]: 
	# 			self.kb.append((clause_num,negated, "{}"))
	# 			clause_num += 1
	
	def resolve(self,c1,c2):
		'''removes contradictions in two clauses and returns list of clauses created'''
		clauses = []
		for a1 in c1[1].split(" "):
			for a2 in c2[1].split(" "):
				if a1 == self.negate_literal(a2) or a2 == self.negate_literal(a1):
					new_clause = " ".join(self.remove(a1,c1) + self.remove(a2,c2)) #remove repated literals 
					
					if not new_clause: #empty clause after remove means contradiction found
						new_clause = "False"
					
					clauses.append(new_clause)

		return clauses

		# return list of literals for new_clause 
	def remove(self,a,c):
		'''remove all a(atoms) from clause(c)'''
		new_clause = [x for x in c[1].split(" ") if a != x]
		
		return new_clause


	def get_kb_set(self):
		'''returns the set of the knowledge base where each element is a clause)'''
		return set([x[1] for x in self.kb]) 
	
	def resolution(self):
		'''use resolution principle to test validy of clause a'''
		new_clauses = set() #set of tuples generated by resolve each element is clause,{parents_num}
		# self.negate_clause(a) #start of algorithm will negate clause then instert into kb
		breakFlag = False 

		# kb_indx = len(self.kb) - 1
		# resolved_clauses = [] #list of parents who have already been resolved
		while True:
				n = len(self.kb)
				pairs = [(self.kb[i],self.kb[j]) for i in xrange(n) for j in xrange(i+1,n)]
				for (c1,c2) in pairs: 
					resolvents = self.resolve(c1,c2)


					
					if "False" in resolvents:
						self.kb.append((len(self.kb) +  1, "False","{%i %i}"%(c1[0],c2[0])))
						return True
					resolve_parents = [(clause, "{%i %i}"%(c1[0],c2[0]))  for clause in resolvents]
				
					new_clauses.update(set(resolve_parents))

					# if len(new_clauses) > 50: return new_clauses 
				if set([x[0] for x in new_clauses]).issubset(self.get_kb_set()): 
					return False

				for c in new_clauses:
					if c[0] not in self.get_kb_set():
						 self.kb.append((len(self.kb)+1,c[0],c[1]))
				
				
 
					# self.resolve(cur_clause,self.find_clause(cur_clause))
					# if self.kb[-1][1] == "False":
					# 	break
					# last_clause = self.kb[-1]

					# if last_clause == cur_clause: #if no new clause was added by resolve
					# 	self.kb.append((len(self.kb) + 1,"Failure","{}"))
					# 	break

	# def find_clause(self,clause):
	# 	'''finds a clause in knowledge base that contains a negated literal in clause'''		
	# 	for atom1 in clause[1].split(" "):
	# 		for ci in self.kb:
	# 			for atom2 in ci[1].split(" "):
	# 				if self.negate_literal(atom1) == atom2 :
	# 					return ci
		

	# 	# return ((len(self.kb) + 1, "Failure","{}"))
	# 	return False

